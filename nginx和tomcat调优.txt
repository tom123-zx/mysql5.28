nginx调优：
增加Nginx运行工作进程数量
进程与cpu绑定，减少上下文切换的次数，提高cpu的缓存命中率
增加Nginx最大打开文件数
nginx采用epoll事件模型，处理效率高，默认就是这个
开启高效传输模式，sendfile on
设置连接超时时间
fastcgi 调优 【与php通信的】
Nginx启用压缩功能需要你来ngx_http_gzip_module模块，gzip调优
expires 缓存调优
内核参数优化
net.ipv4这些网络参数优化

MySQL5.7优化：
SQL语句和索引
数据表结构
系统配置
硬件

mysql主从复制延迟如何解决：
1.从服务器配置过低导致延迟
升级从服务器的配置,让只读节点的配置大于或者等于主节点的配置即可
2.主库的QPS过高导致只读节点延迟
开启只读节点的并行复制 (mysql5.6.3以后支持多线程复制)
3.主库的DDL语句导致只读节点延迟
可以kill掉只读节点上的大查询进行，就可以恢复只读节点与主节点的数据同步
4.主库执行大事务导致延迟
将大事务拆分成为小事务进行排量提交，这样只读节点就可以迅速的完成事务的执行，不会造成数据的延迟。
5.无主键的表进行DML操作导致延迟
每张表在设计的时候都加上一个主键

总结：
1.数据库设置: 主从同步加速
2.架构方面:在架构上做优化,尽量让主库的DDL快速执行,尽量减轻数据库的压力
3.硬件方面:使用比主库更好的硬件设备作为slave
（1）写操作后的读操作指定发给数据库主服务器
（2）读从机失败后再读一次主机，进行二次读取
（3）关键业务读写操作全部指向主机，非关键业务采用读写分离 

单线程的redis为什么这么快
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制

redis的内存会越来越高。那么就应该采用内存淘汰机制。
在redis.conf中有一行配置
maxmemory-policy volatile-lru(策略)
该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)

Redis 常见性能问题和解决方案？
(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2…


如果redis出现阻塞怎么办？
导致Redis阻塞分为内在原因和外在原因：
内在原因：不合理使用API或数据结构、CPU饱和、持久化阻塞等
外在原因：CPU竞争、内存交换、网络问题等

定位慢查询
Redis原生提供慢查询统计功能，执行 showlog get {n} 命令可以获取最近n条慢查询命令，Redis默认记录仪执行超过10毫秒的记录。

如果开发执行的sql语句有问题你要怎么找出来
slow_query_log 这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句
long_query_time 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短
slow_query_log_file 记录日志的文件名
log_queries_not_using_indexes 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句

redis和memcached的区别是什么
1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，redis可以持久化其数据
2)、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储
3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4). value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。
5）redis的速度比memcached快很多
6）Redis支持数据的备份，即master-slave模式的数据备份。
