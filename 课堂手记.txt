
ftp://10.3.145.2    

VNC Servr: 10.3.145.251
Password: 1902

VNC           -  远程桌面
Vmware        -  虚拟机
cherrytree    -  笔记
typora        -  笔记

1.终端问题

mkdir  
rm -rf
mv  
cp -r
ls

touch 
>
rm -rf
cat  less  more head tail tac

ifdown ens33;ifup ens33
yum install vim -y

vi  
vim

命令模式:
行间跳转
G
10gg
gg

行内
^
$
Home
End

复制行
yy  复制一行
3yy  复制从光标所在行起,一共复制3行
yG   复制从光标所在行起,下方所有的行
ygg

粘贴行
p   将复制的行粘贴到光标所在行的下方

dd  删除一行
3dd

单词
yw    从光标所在的字符复制到这个单词的词尾

dw

p

字符
x    删除光标所在的字符
r    单个字符替换

u    撤销
^r   反撤销
ZZ   保存退出


编辑模式(插入模式)
i a o I A O
i 在光标所在位置前面插入字符   insert
a 在光标所在位置后面追加字符   append
o 在光标所在行的下一行插入字符

末行模式
:w   保存		write
:q[!]   退出(不保存)		quit
:wq[!]  保存退出
:r file  将其它文件的内容读到当前文件中光标所在行的下方
:d	删除光标所在行
:3d      删除第3行
:5,10d	删除第5行到第10行
:10,$d  删除第10行到最后一行
:s/root/ROOT/ 将光标所在行的第一个root替换成ROOT
:2s/bin/BIN/  将第2行的第一个bin替换成BIN
:2,5s/bin/BIN/g 将第2行到第5行的所有bin替换个BIN            global
:%s/bin/BIN/  将所有行的第一个bin替换成BIN
:%s/bin/BIN/g 将所有的bin替换个BIN

:nohl   	取消高亮
/关键字  	全篇查找关键字(高亮显示)
:set nu		显示行号
:set nonu	取消显示行号
:set ts=4	设置tab键的宽度

可视模式
ctrl+v   
批量删除,ctrl+v进入可视块,按方向键选中需要删除的字符,按x删除
批量注释(在所有的行前面加#):
将光标定位到第一行或最后一行的第一个字符,ctrl+v,选中每一行的第一个字符,I,#,Esc,Esc  

重定向
文件描述符
0 - 标准输入  键盘输入
1 - 标准输出 - 程序正确执行后输出在当前终端上的内容  
	eg: # cat /etc/passwd   //正常输出内容
2 - 错误输出 - 程序错误执行后输出在当前终端上的内容  
	eg: $ cat /etc/shadow   //权限不够

1>  -  标准输出重定向              /dev/null  黑洞设备
	屏蔽标准输出:   1> /dev/null
1>> -  标准输出追加重定向
2>  -  错误输出重定向
	屏蔽错误输出:	2> /dev/null
2>> -  错误输出追加重定向
&>  -  所有输出重定向       
	屏蔽所有的输出: &> /dev/null
2>&1 - 将错误输出重定向到标准输出的通道
1>&2 - 将标准输出重定向到错误输出的通道

# ls a.txt anaconda-ks.cfg | wc -l
ls: 无法访问a.txt: 没有那个文件或目录     //ls命令的错误输出
1                                         //wc -l的输出, 错误输出不会通过管道流下来

# ls a.txt anaconda-ks.cfg 2>&1 | wc -l
2

<   -  输入重定向,一般省略不写

<<  -  用于定义输入结束符,输入中输入结束符一定要顶格写
<<- -  用法同上,区别是在输入中输入结束符可不用顶格写

# cat >> /tmp/a.txt << eof
# cat << eof >> /tmp/a.txt
以上两种写法一样,出现eof表示输入结束

管道 - 将管道前面命令的标准输出作为后面命令的标准输入

例1:打印/etc/passwd文件的第8行内容:
# head -8 /etc/passwd | tail -1

例2:带行号打印/etc/passwd文件的第5行到第7行内容:
# head -7 /etc/passwd | cat -n | tail -3

cat,head,tail...
输入:
1.标准输入
	# cat    如果不接文件,cat会等待标准输入,并把标准输入输出到标准输出
eg:# cat -n                 //按ctrl+d结束输入
lfkjsfdlsa
     1  lfkjsfdlsa
2.文件重定向
cat < /tmp/a.txt
3.管道



wc 

echo : 输出参数,自带换行符
  -n  去掉换行符

ip永久配置:
网卡配置文件: /etc/sysconfig/network-scripts/ifcfg-ens33
改:
BOOTPROTO=static
ONBOOT=yes
添加:
IPADDR=你自己的IP(我的是192.168.10.130)
GATEWAY=你的网关IP(选填)
DNS1=114.114.114.114(选填)

改好后保存退出
ifdown ens33;ifup ens33

虚拟机上网(NAT连接):
1.配置好IP
2.找到网关地址: 编辑-虚拟网络编辑器-NAT模式-NAT设置
如果网卡配置文件中没有配置GATEWAY和DNS,则需要以下两步:
3.设置网关: route add default gw 你的网关地址
4.设置DNS: echo "nameserver 114.114.114.114" >> /etc/resolv.conf

ping www.baidu.com测试能否上网

如果可以上网,安装lrzsz: yum install -y lrzsz 
sz 文件名    发送文件
rz	     接收文件

================用户和组管理====================
用户名-----姓名
UID--------工号
基本组-----基本岗位
附加组-----附加岗位

/etc/passwd  所有用户的信息
用户名:密码位:uid:gid:描述信息:家目录:登录shell
/etc/shadow  用户的密码信息

/etc/group   所有的组信息
/etc/gshadow 组密码信息

增删改查
useradd [选项]...  用户名        #创建用户
 -u	指定UID
 -g	指定基本组
 -d	指定家目录
 -s	指定登录shell
 -M     不创建家目录

创建用户时,默认会创建一个和用户同名的组,作为用户的基本组
如果要指定基本组,该组一定要存在

usermod [选项]...  用户名         #修改用户信息
 -G	指定用户新的附加组列表,会覆盖原来的附加组
 -a	和-G一起使用,添加用户的附加组

id [选项]... 用户名               #查看用户信息
 -u	仅打印UID
 -g	仅打印GID
 -n	结合-u或-g,仅打印用户名或组名
例: 查看tom的信息
# id tom
uid=1000(tom) gid=1000(tom) 组=1000(tom),8888(boss),10001(natasha)

userdel   [-r]  用户名            #删除用户
 -r	删除用户时清除用户数据(家目录,邮箱)

passwd [选项] [用户名]
普通用户只能设置自己的密码
超级用户可以设置所有用户的密码
  --stdin	从标准输入读取
  eg: echo 123 | passwd --stdin tom

su [-] [用户名]  切换用户
超级用户切换不需要密码
普通用户一定要密码

组的管理
groupadd
groupmod
groupdel

组成员管理
gpasswd  option  组名
  -a user		添加成员,不会覆盖原有成员
  -M user1[,user2...]	设置成员,会覆盖原有成员
  -d user		删除成员


用户名,组名为数字的问题

======================权限======================================
什么用户(组)对什么文件可以做什么操作
每个文件都属于一个特定的用户(所有者)及一个特定的组(属组) 

查看文件的归属:ls -ld  文件名
第三列: 所有者
第四列: 所属组

改变文件归属:
chown [选项] [所有者][:[所属组]]  文件...
# chown jerry a.txt   //将a.txt的属主改为jerry
# chown :IT a.txt     //将a.txt的属组改为IT   :也可用.
# chown laozhang:laozhang a.txt    //

三种角色(身份): 
所有者 user
所属组 group
其他人 other

角色匹配的优先级
所有者 > 所属组 > 其他人
1.先看用户是否文件的所有者,如果是,则应用所有者的权限
2.如果第1步中不是所有者,再看是否文件所属组的成员,如果是,则应用所属组的权限
3.如果以上2步均不是,则应用其他人的权限

UGO权限
U - user    所有者
G - group   所属组
O - other   其他人

-rw-r--r-- 1 laozhang laozhang 6 7月  25 14:08 a.txt
  U  G  O
                          普通文件			        目录
r(4)  -  读read           cat,head,tail,more,less,tac...        ls
w(2)  -  写write          vim, >                                创建,删除,cp,mv
x(1)  -  执行execute      路径(如果没有,root用户也不可执行)     cd 基本权限

目录:
x是基本权限,r/w都在有x权限的前提下才有意义

普通文件:
rwx要以能进入文件所在的目录为前提


改变文件的UGO权限: chmod
chmod 身份(ugoa)运算符(+-=)权限(rwx-)

目录中存放的是文件名与inode的对应关系
inode中存放着文件的元数据(权限,大小,归属,时间,存放的具体位置)

最小权限
查看文件内容:  对文件本身r,对文件所在目录有x权限
修改文件内容:  ..........w,...............x.....
修改文件名称:  对文件所在目录有wx权限


================高级权限SUID,SGID,SGICKEY=========================
SUID - 4
 作用于可执行文件,当用户执行此文件时,可临时获得该文件所有者的权限
chmod u+s 可执行文件
实验:
1.cp /usr/bin/cat  /opt/            //得到可执行文件/opt/cat
2.将/opt/cat属主改为jerry
3.切换到tom用户,使用/opt/cat不能看到jerry家目录下内容
4.切换到root用户,给/opt/cat赋予SUID权限
5.切换到tom用户,使用/opt/cat可以看到jerry家目录下内容

SGID - 2
 1.作用于可执行文件,当用户执行此文件时,可临时获得该文件所属组的权限
 2.作用于目录,在该目录下创建文件会继承该目录的属组
chmod g+s  目录或可执行文件
实验:
1.创建一个目录/test
2.将/test目录属组改为IT
3.给/test目录赋予SGID权限
4.在/test目录下创建文件或目录,观察属组

STICKY - 1
 作用于共享目录,用户只能删除自己的文件
chmod o+t 共享目录
实验:
1.创建共享目录/share(权限777)
2.tom用户在此目录下创建文件,jerry用户可以随意删除
3.给/share目录赋予STICKY权限
4.tom用户在此目录下创建文件,其他普通用户不能删除了

===================文件访问控制列表 file access control list===========
满足用户个性化的权限需求
getfacl: 查看文件的访问控制列表
setfacl: 设置文件的访问控制列表

[root@desk ~]# getfacl  /pub/root.txt 
getfacl: Removing leading '/' from absolute path names
# file: pub/root.txt
# owner: tom
# group: tom
user::rw-
user:jerry:r--         #访问控制列表中的条目
group::r--
mask::r--
other::---

实验:
1.创建文件/pub/a.txt,权限为600,属主属组为root
2.分别使用tom用户和jerry用户访问此文件
3.使用setfacl命令授权jerry用户对此文件有访问权限
4.重复第2步,对比结果

========================隐藏权限 - 防误删============================
i位: 所有用户(含root)不能修改或删除文件
a位: 所有用户(含root)不能删除文件,但有写权限的用户可向文件中追加内容
lsattr: 查看文件的隐藏权限
chattr: 设置文件的隐藏权限

jerry jerry
-w-rw----

jerry

========================高级文件管理=================================
文件的时间 stat :查看文件的元数据信息
访问时间 	atime    文件一天中第一次被访问的时候会改变
内容修改时间	mtime	 文件的内容被修改的时候会改变,同时会改变ctime
属性修改时间	ctime	 文件的属性被修改的时候会改变

文件查找
find特点:递归查找,隐藏文件也会查找.
用法一: find [查找范围]  查找条件
查找条件:
   -atime	n	n天前访问过的文件
	eg:查找/tmp目录下2天前访问过的文件: find /tmp -atime +2
   -empty		空文件或目录
	eg:查找/tmp目录下的空目录: # find /tmp/ -type d   -empty
   -iname pattern	以文件名作为查找条件,文件名不区分大小写,支持通配符***
			通配符:  * 所有     ? 任意单个字符
			例: a* 表示以a开头的文件,*a 以a结尾, *a* 文件名中包含的a
			    a? 表示以a开头,文件名共2个字符的文件
	eg:查找/test目录下所有以a开头的文件,不区分大小写:
    -name pattern	以文件名作为查找条件,文件名区分大小写,支持通配符***
	-perm mode	以文件权限作为查找条件
			例:-perm g=w  	仅查找权限为020的文件 
			例:-perm -g=w	查找所有的所属组有写权限的文件
    -size +1G	以文件大小作为查找条件 M G
	eg:全盘查找大于50M的文件:# find / -size +50M
    -type c		以文件类型作为查找条件: f:普通文件, d:目录, l:链接
	eg:查找tom用户的所有的普通文件: # find / -user tom -a -type f 
	

多条件查找:
  	条件1 [-a] 条件2 	与的关系:多个条件同时满足
	条件1 -o 条件2		或的关系:满足其中任一条件
	-not 条件		非: 取反

用法二: find [查找范围]  查找条件  -exec  操作 \;
在操作中使用{}代替查找到的文件
操作:查找到一个文件执行一次操作
例:查找所有的a.txt并删除
# find  / -name a.txt -exec rm -rf {} \;

正例:查找所有tom用户的普通空白文件,并删除
# find / -user tom  -type f  -empty -exec rm -rf {} \;

反例:查找所有以.conf结尾的文件,并压缩保存到/backup目录下
这个例子需要一次性处理所有查找到的文件,这种情况不适合使用-exec处理
# find / -name "*.conf" | xargs  tar -caf /backup/conf.tar.gz 


grep:文件内容过滤
语法: grep [选项] 关键字  文件名
位置关键字: ^ 行首      $ 行尾     ^$ 空行
常用选项:
	-v	取反
	-n	带行号打印
	-i	不区分大小写
	-w	将关键词作为一个完整的单词进行匹配
	-R	递归匹配,作用对象为目录,grep会递归匹配目录下所有的文件
例:打印出/etc/passwd文件中所有的可登录用户信息
# grep "sh$" /etc/passwd

cut:处理列
cut 选项 文件
常用选项:
	-d	指定分隔符
	-f	指定打印的列
说到列就应该想到分隔符
例:打印所有的用户名(passwd文件第一列)
# cut -d ":" -f 1  /etc/passwd


tr:字符的替换,缩减,删除
tr -s 字符	把连续的字符缩减为一个
例:删除/etc/rc.local文件中的空行
分析:空行是由连续的换行符(\n)造成
# cat /etc/rc.local |tr -s "\n" 

tr -d 字符	删除指定的字符
例:删除"80%"中的%
# echo 80% |tr -d %

tr 字符1 字符2  将字符1替换为字符2  字符可以是多个 a-z表示所有的小写字母
例:将file文件中所有的小写字母转换为大写字母:
# cat file |tr a-z A-Z

sort:排序
默认以第一个字符按照升序的方式进行排序
语法: sort [选项] 文件
常用选项:
	-n	按照数值大小进行排序
	-r	按照降序的方式进行排序
	-t	指定列分隔符
	-k	与-t结合使用,指定排序的列
例:将/etc/passwd文件后10行按照UID从大到小打印出来:
# tail /etc/passwd|sort -t ":" -k 3 -nr

uniq:去重,去掉连续重复的行
语法: uniq [选项] 文件
	-c	去重并统计连续的行数
例:统计系统中所有用户不同种类shell的数量
# cut -d ":" -f 7 /etc/passwd|sort |uniq -c

tee:将标准输入同时输出到标准输出和文件中,默认会覆盖文件的内容
语法: tee [选项] 文件
常用选项:
	-a	如果文件存在,将输出追加到文件中
例:将上面的uniq例子中的结果输出并保存到/tmp/shell文件中
# cut -d ":" -f 7 /etc/passwd|sort |uniq -c |tee /tmp/shell

xargs:传递参数
将标准输入传递给后面的处理命令,默认作为处理命令的最后一个参数
常用选项:
	-n	指定一次传递的参数个数, 默认传递全部参数
	-i	将要传递的参数赋值给{}
例:一行命令查看tom,lily,jerry的信息:
# echo "tom lily jerry" |xargs -n1 id

which:查看外部命令的路径
# which cat   //查看cat命令的绝对路径

type:查看命令的类型 (内嵌,外部,别名)
# type cd     //用于查看cd命令的类型

alias:定义或查看别名
# alias       //查看系统中所有的别名
# alias hello='echo hello world'   //定义一个命令hello,作用是输出hello world.
# unalias hello                    //取消别名hello


============================打包压缩==================================
yum install zip unzip -y              //软件安装
zip:将文件压缩为zip格式    .zip
语法: zip  [选项]  压缩后的包名  要压缩的文件列表
常用选项:
	-r	如果要压缩的文件列表中有目录,要加上此选项

unzip:将zip格式的压缩包进行解压,默认解压到当前目录下
语法: unzip  zip压缩包  [-d 要解压到的路径]
---------------------------------------------------------
这两个压缩程序在压缩完成后原文件会消失 
压缩		解压
gzip    -----	gunzip     .gz
bzip2   -----	bunzip2    .bz2
---------------------------------------------------------
tar  归档程序
语法: tar [选项]...  文件...
归档:
	-c	创建归档文件
	-x	释放归档文件的内容
	-f	接归档后的文件名,必选项
	-t	查看归档的内容
	-C	将归档文件释放到指定的目录
命名:如果是tar做的归档,使用.tar做后缀 

压缩选项:
	-j	调用bzip2程序进行压缩    .tar.bz2      //yum install bzip2 -y
	-z	调用gzip程序进行压缩     .tar.gz
	-J	调用xz程序进行压缩	 .tar.xz
	-a	通过规范的压缩文件名自动选项相应的压缩程序进行压缩
例1: 将/boot目录压缩存放到/backup目录
# tar -caf /backup/boot.tar.gz  /boot

例2: 将/backup/boot.tar.gz解压到当前目录中
# tar -xf /backup/boot.tar.gz

例3: 查看/backup/boot.tar.gz压缩包中的内容
# tar -tf /backup/boot.tar.gz

例4: 将/backup/boot.tar.gz解压到/opt目录中
# tar -xf /backup/boot.tar.gz  -C /opt



du:统计文件的大小
语法: du [选项]  文件名
选项:
	-s	只显示统计信息
	-h	以人类易读的方式显示
例:统计/etc目录下所有文件的总大小
# du -sh /etc/

date: 处理系统日期时间
自定义显示格式: date +格式
格式:
	%Y	年(4位)
	%m	月
	%d	日
	%H	小时(24小时制)
	%M	分
	%S	秒
	%F	完整的日期格式,等价于%Y-%m-%d
	%T	完整的时间格式,等价于%H:%M:%S 
设置系统时间: date -s "YYYY-mm-dd HH:MM:SS"
例:打印出当前系统时间,显示格式为YYYY-mm-dd HH:MM:SS
# date +"%Y-%m-%d %H:%M:%S"
# date +%Y-%m-%d\ %H:%M:%S     //  \:转义符 将有特殊含义的字符转为本义
                               //   某些没有特殊含义的字符转为有特殊含义 \n \t
# date +"%F %T"

`` 反引号,``内是一个命令,这个命令的输出结果将作为另一个命令的参数进行引用,等价于$()
例:输出:"Tom's UID is XXX",将XXX替换为tom用户的真实UID
# echo "Tom's UID is `id -u tom`"
# echo "Tom's UID is $(id -u tom)"

"" 双引号, 弱引:双引号内部的``或变量可以被替换掉
'' 单引号, 强引:引号内的内容会原原本本的输出
# echo "上一条命令的返回值是:$?"     //""中的$?会被替换为具体的数字
# echo '$?能够反映出上一条命令的执行结果'  // ''中的$?会原原本本输出
	

命令连接符:
;   连接多条命令,按照从左到右的顺序依次执行   ifdown ens33;ifup ens33
&&  逻辑与:  前面的命令正确执行后,后面的命令才会执行
	eg: 如果用户tom存在,则输出用户已存在
	# id tom &> /dev/null && echo "用户已存在"
||  逻辑或:  前面的命令错误执行,后面的命令才执行
	eg: 如果用户tom不存在,则创建用户

$?  上一条命令执行返回码 0表示上一条命令成功执行,非0表示上一条命令错误执行

!  逻辑非: 

1.尽量不要使用多个逻辑符号
2.如果要使用多个,使用&&,避免使用||

==================================磁盘====================================
1.查看系统配置
  CPU:  lscpu       /proc/cpuinfo
  内存: free        /proc/meminfo
  磁盘: lsblk

2.磁盘命名
  并口(IDE) - > hdx
  串口      - > sdx
  虚拟	    - > vdx

3.磁盘分区
  分区表类型: MBR   GPT
  MBR: <=2T的磁盘
    磁盘标签类型: msdos 或 dos,不同的分区工具显示的可能不一样
    主分区,扩展分区,逻辑分区
    最多只支持4个主分区,最多1个扩展分区
    扩展分区和主分区共用4个分区编号(1-4),扩展分区不能直接使用,必须要划分逻辑分区才能使用

  GPT: 所有磁盘
    磁盘标签类型: gpt
    没有主分区,扩展分区这样的概念,支持128个分区
    
4.使用fdisk进行磁盘分区并使用
 1).将磁盘进行分区      fdisk
 2).通知内核重读分区表  # partprobe
 3).格式化分区(做一个文件系统) # mkfs.xfs  /dev/sdb1    //将/dev/sdb1格式化为xfs文件系统
 4).挂载,将存储设备挂载到一个目录,这个目录被称为设备的挂载点  mount /dev/sdb1 /mnt
    通过挂载点可以访问设备中的数据

5.使用parted进行磁盘分区
 msdos  ->  MBR
   1).对于新添加的磁盘,要指定磁盘标签类型(msdos,gpt)
   # parted /dev/sdb mklabel msdos            //新磁盘需要
   2).分区
   # parted /dev/sdb mkpart p 0 1G         //语法: mkpart 分区类型 起始大小 结束大小
   # parted /dev/sdb mkpart e 1G 5369MB    //扩展分区
   # parted /dev/sdb mkpart l 1000M 2000M  //逻辑分区
   3).通知内核重读分区表
   4).格式化
   5).挂载使用

 gpt ->  GPT
   1).对于新添加的磁盘,要指定磁盘标签类型
   2).分区
   # parted /dev/sdb mkpart pi 0 1G    //语法: mkpart 分区名称 起始大小 结束大小
   3).通知核重读分区表
   4).格式化
   5).挂载使用

swap:交换分区
将磁盘上的部分空间当作内存来使用,这部分空间被称为交换分区.
当物理内存不够用时,将内存中某些进程暂时不用的数据换出到交换分区;
当需要使用到这些数据时,再从交换分区换入到物理内存中.

因为磁盘的速度远低于内存的速度,所以频繁的换入换出会降低系统性能.

安装操作系统时合理规划swap大小:
对于运行普通的应用的机器,swap建议设置为物理内存的1-1.5倍
对于运行某些需要高性能应用的机器,如K8S,建议关闭swap

MBR: Main Boot Record
位于磁盘的第一个扇区,512B
bootloader(446)+分区表(64)+魔数(2)

逻辑卷管理 LVM
概念:
物理卷: PV   真实存在的磁盘或分区
卷组: VG     逻辑概念,将多个物理卷整合在一起所形成的一个组
逻辑卷: LV   逻辑概念,从卷组中划分出来的一部分空间,真正使用的空间,可以动态扩容

命令:
	查看	创建		扩展		删除		缩容
PV	pvs	pvcreate	-		pvremove	-
VG	vgs	vgcreate	vgextend	vgremove	vgreduce
LV	lvs	lvcreate	lvextend	lvremove	-

一个创建逻辑卷的完整过程:
1.创建物理卷
# pvcreate  /dev/sdb{1..6}      //将/dev/sdb的1-6个分区创建为物理卷
2.创建卷组
# vgcreate vg0  /dev/sdb{1..3}  //将3个物理卷整合为卷组vg0
3.创建逻辑卷
# lvcreate vg0 -n lv0 -L 1G     //从卷组vg0中创建逻辑卷lv0,大小为1G
4.格式化逻辑卷
# mkfs.xfs /dev/vg0/lv0         
5.挂载使用
# mount /dev/vg0/lv0  /lv0/  

将lv进行在线扩容的过程:
例:将上面创建的lv0在线扩容至2G
1.检查lv0所在的vg0有没有足够的空间来扩容,两种情况:
# vgs
  情况1: vg0没有足够的空间,先将vg0扩容
  # vgextend vg0  /dev/sdb{4..6}
  情况2: vg0有足够的空间,则进行下一步
2.将lv0扩容至2G
# lvextend -L +1G /dev/vg0/lv0
3.在文件系统级别在线扩容
# xfs_growfs  /lv0/           


程序和进程
程序: 保存在磁盘上,代码和数据的集合
进程: 运行在内存中,具有生命周期

进程的查看
ps
top
pstree
pgrep

进程的前后台调度
将前台进程调度到后台暂停: ^Z	
将后台进程在后台继续运行: bg命令
将后台进程调度到前台运行: fg命令
查看后台进程: jobs
从后台启动一个程序: 在启动命令后加 &



NFS:
配置过程
服务器端:
1.安装软件: yum install nfs-utils -y
2.配置共享: 修改/etc/exports文件   格式: 共享目录    共享给谁(共享属性)
3.启动服务: systemctl start nfs-server

客户端:
1.安装软件
2.查询共享: showmount -e  服务器IP
3.挂载: mount 服务器IP:共享目录   挂载点

NFS使用-权限
1.共享属性为只读,客户端不可写,错误信息:只读文件系统
2.共享属性为读写:
 客户端对目录无写权限,依然不可写.错误信息: 权限不够
 原因: 客户端上的root默认会被映射为nfsnobody用户
 解决方法:
   1).在服务上修改目录权限,让nfsnobody用户可写,不建议
   2).共享时设置客户端root用户不映射  no_root_squash


FTP:
主动模式
1.客户端向服务器的21号端口建立管理连接   - 管理连接
2.服务器通过20号端口向客户端发送数据     -  数据连接

被动模式
1.客户端向服务器的21号端口建立管理连接   - 管理连接
2.服务器开启随机数据端口,客户端与该端口建立连接,获取数据   - 数据连接

匿名用户家(根)目录: /var/ftp

linux客户端: lftp用法
  !命令		执行shell命令
  cd		切换目录
  ls		查看文件
  get		下载单个文件,可接-o选项指定下载到什么目录
  mget		下载多个文件
  put		上传单个文件
  mirror	下载目录	

上传普通文件:
修改/etc/vsftpd/vsftpd.conf
上传文件: 1.anon_upload_enable=YES  2.对上传所在目录要有写权限
/var/ftp目录权限不要改

上传目录:
anon_mkdir_write_enable=YES



DNS
查询过程
1.  /etc/hosts
2.  缓存
3.  客户端 -> 配置的DNS服务器      //请求www.baidu.com的主机地址
4.  DNS服务器 -> .                 //请求www.baidu.com, 返回com域的DNS服务器地址   -- 迭代
5.  DNS服务器 -> com               //请求www.baidu.com, 返回baidu.com域的DNS服务器地址 -- 迭代
6.  DNS服务器 -> baidu.com         //请求www.baidu.com, 返回www.baidu.com主机的地址 -- 递归
7.  DNS服务器 -> 客户端            //返回www.baidu.com的主机地址  -- 递归

问题:
zone文件中的主机名是哪个域中的主机,它的全质量域名是什么?


排错思路:
1.服务起不来
  1).检测配置文件(主配置文件,区域配置文件)语法;
  2).日志 messages

2.服务正常,但客户端无法解析(DNS服务器一定要设置正确)
  1).在服务器本机上进行测试,127.0.0.1,通信地址
  2).如果都不能解析,查看zone文件的权限,selinux;如果只有127.0.0.1可以解析,查看主配置文件监听套接字及allow-query的配置
  3).如果本机可以解析,客户端不能解析,查看防火墙


data sport dport a-ip e-ip  a-mac  r1-mac
data sport dport a-ip e-ip  r2-mac  e-mac   NAT

192.168.10.130/8         192.100.10.100/8
网络位
主机位

11000000.10101000.00001010.10000010
11111111.11111111.11111111.00000000
11000000.10101000.00001010.00000000  => 192.168.10.0
                                     => 192.168.10.0

橙白 橙  绿白  蓝  蓝白 绿  棕白  棕  568B
1    2    3             6


127.0.0.1 - 127.255.255.255

在一个网络中,主机位全0为网络号, 全1为广播地址

IP地址划分                第一个字节   保留        私有IP范围
00000000    A/8    	  0   - 127    0,127       10.0.0.0-10.255.255.255
10000000    B/16	  128 - 191    169.254     172.16.0.0-172.31.255.255
11000000    C/24    	  192 - 223                192.168.0.0-192.168.255.255
11100000    D    	  224   
11110000    E    	  240

子网划分 
例:
192.168.10/26                           网络号		   广播地址
11000000.10101000.00001010.11 000000    192.168.10.192/26  192.168.10.255
11000000.10101000.00001010.10 000000    192.168.10.128/26  192.168.10.191
11000000.10101000.00001010.01 000000    192.168.10.64/26   192.168.10.127
11000000.10101000.00001010.00 000000    192.168.10.0/26    192.168.10.63
11111111.11111111.11111111.11 000000


1.多少个子网   借了多少位 x    2^x
2.每个子网的网络号及广播地址   
3.每个子网的有效主机数         2^(32-掩码长度)-2

练习:
192.168.10.200/27网络号是多少? 此网络的广播地址是多少? 本网络中有多少个有效IP地址?

基本元字符
功能:
  字符
	.		任意单个字符

	[]		[]内的任意单个字符
	[a-z]		任意单个小字字母
	[a-zA-Z0-9]	所有单个字母或数字
	[^0-9]		除了数字外的任意单个字符,[]中首位为^表示取反

  次数
	*		*前面的字符重复任意次数(包含0次)
	\{N\}		括号前面的字符刚好重复N次
	\{,N\}		括号前面的字符最多重复N次
	\{N,\}		括号前面的字符最少重复N次
	\{N,M\}		括号前面的字符重复N次到M次
  位置
	^		行首
	$		行尾
	\<		词首
	\>		词尾

扩展元字符
	+		+前面的字符至少重复一次
	?		?前面的字符重复最多一次,防贪婪
	{}		意义同基本元字符中的\{\}
	|		或
	()		分组
	\数字		对分组的内容进行引用



写一个脚本,在执行时参数接人名,输出"Hello,XXX"(XXX为所接的人名参数); 
如果在执行时未接参数,则输出"Hello,everyone"



写一个脚本,要求用户输入出生年份:
如果用户输入为空,则提示"输入不能为空",并退出,返回值为1;
如果用户输入的不是数字,则提示"输入错误",并退出,返回值为2;
如果用户出生于2000年以后,则输出00后;如果出生于1990-1999,则输出90后;否则,输出"老年人".



猜数字游戏
随机生成一个1-100的数字,提醒用户猜.
1).只能猜6次,在6次内如果猜对了,提示"你赢了",并退出;
2).用户每次猜后要提示用户猜大了或小了.如正确答案为50,用户猜30,则提示猜小了;
3).用户每次猜前要提示剩余次数;
4).用户输入为空,或输入不是数字都将浪费一次可用次数;
5).当次数用完还没猜出则提示"你输了",并给出正确答案.





双色球
红球: 1-33    6个
蓝球: 1-16    1个

思路一: 定义空数组,生成红球放进数组,当球数达到6时停止放入
	问题: 去重


思路二: 将所有红球定义为数组,从数组中往外拿


1.使用while循环统计每种shell的个数,按照数量从多到少输出出来

1.写一个脚本,执行后生成一个UUID(不要使用uuidgen命令)
2.改写上面的脚本,执行时参数接uuid(UUID)生成一个uuid,接mac(MAC)生成一个MAC地址

uuid:
16进制数字
8-4-4-4-12   
如: 8dda6bd3-63f7-4dfa-b4f1-6766fa9bf089

MAC:
16进制数字
2:2:2:2:2:2
如: a4:ba:db:3e:e1:c5













































